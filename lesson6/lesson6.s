;
; File generated by cc65 v 2.16 - Git N/A
;
	.fopt		compiler,"cc65 v 2.16 - Git N/A"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_NMI_flag
	.export		_Frame_Count
	.export		_index
	.export		_index4
	.export		_A_X
	.export		_A_Y
	.export		_B_X
	.export		_B_Y
	.export		_A_right_side_X
	.export		_A_left_side_X
	.export		_A_bottom_Y
	.export		_A_top_Y
	.export		_B_right_side_X
	.export		_B_left_side_X
	.export		_B_bottom_Y
	.export		_B_top_Y
	.export		_state
	.export		_state4
	.export		_B_state
	.export		_B_state4
	.export		_B_state_count
	.export		_joypad1
	.export		_joypad1old
	.export		_joypad1test
	.export		_joypad2
	.export		_joypad2old
	.export		_joypad2test
	.export		_score1
	.export		_score2
	.export		_score3
	.export		_score4
	.export		_score5
	.export		_PPU_flag
	.export		_SPRITES
	.export		_PALETTE
	.export		_MetaSprite_Y
	.export		_MetaSprite_Tile
	.export		_MetaSprite_Attrib
	.export		_MetaSprite_X
	.export		_All_Off
	.export		_All_On
	.export		_Reset_Scroll
	.export		_Load_Palette
	.export		_update_Sprites
	.export		_move_logic
	.export		_collision
	.export		_PPU_Update
	.import		_Get_Input
	.export		_main
	.export		_every_frame

.segment	"RODATA"

_PALETTE:
	.byte	$19
	.byte	$00
	.byte	$00
	.byte	$1F
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$19
	.byte	$37
	.byte	$24
	.byte	$01
	.byte	$00
	.byte	$37
	.byte	$26
	.byte	$06
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_MetaSprite_Y:
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$08
_MetaSprite_Tile:
	.byte	$02
	.byte	$03
	.byte	$12
	.byte	$13
	.byte	$00
	.byte	$01
	.byte	$10
	.byte	$11
	.byte	$06
	.byte	$07
	.byte	$16
	.byte	$17
	.byte	$04
	.byte	$05
	.byte	$14
	.byte	$15
_MetaSprite_Attrib:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_MetaSprite_X:
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$08

.segment	"BSS"

.segment	"ZEROPAGE"
.segment	"OAM"
.segment	"ZEROPAGE"
_NMI_flag:
	.res	1,$00
.segment	"ZEROPAGE"
_Frame_Count:
	.res	1,$00
.segment	"ZEROPAGE"
_index:
	.res	1,$00
.segment	"ZEROPAGE"
_index4:
	.res	1,$00
.segment	"ZEROPAGE"
_A_X:
	.res	1,$00
.segment	"ZEROPAGE"
_A_Y:
	.res	1,$00
.segment	"ZEROPAGE"
_B_X:
	.res	1,$00
.segment	"ZEROPAGE"
_B_Y:
	.res	1,$00
.segment	"ZEROPAGE"
_A_right_side_X:
	.res	1,$00
.segment	"ZEROPAGE"
_A_left_side_X:
	.res	1,$00
.segment	"ZEROPAGE"
_A_bottom_Y:
	.res	1,$00
.segment	"ZEROPAGE"
_A_top_Y:
	.res	1,$00
.segment	"ZEROPAGE"
_B_right_side_X:
	.res	1,$00
.segment	"ZEROPAGE"
_B_left_side_X:
	.res	1,$00
.segment	"ZEROPAGE"
_B_bottom_Y:
	.res	1,$00
.segment	"ZEROPAGE"
_B_top_Y:
	.res	1,$00
.segment	"ZEROPAGE"
_state:
	.res	1,$00
.segment	"ZEROPAGE"
_state4:
	.res	1,$00
.segment	"ZEROPAGE"
_B_state:
	.res	1,$00
.segment	"ZEROPAGE"
_B_state4:
	.res	1,$00
.segment	"ZEROPAGE"
_B_state_count:
	.res	1,$00
.segment	"ZEROPAGE"
_joypad1:
	.res	1,$00
.segment	"ZEROPAGE"
_joypad1old:
	.res	1,$00
.segment	"ZEROPAGE"
_joypad1test:
	.res	1,$00
.segment	"ZEROPAGE"
_joypad2:
	.res	1,$00
.segment	"ZEROPAGE"
_joypad2old:
	.res	1,$00
.segment	"ZEROPAGE"
_joypad2test:
	.res	1,$00
.segment	"ZEROPAGE"
_score1:
	.res	1,$00
.segment	"ZEROPAGE"
_score2:
	.res	1,$00
.segment	"ZEROPAGE"
_score3:
	.res	1,$00
.segment	"ZEROPAGE"
_score4:
	.res	1,$00
.segment	"ZEROPAGE"
_score5:
	.res	1,$00
.segment	"ZEROPAGE"
_PPU_flag:
	.res	1,$00
.segment	"OAM"
_SPRITES:
	.res	256,$00

; ---------------------------------------------------------------
; void __near__ All_Off (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_All_Off: near

.segment	"CODE"

;
; PPU_CTRL = 0;
;
	lda     #$00
	sta     $2000
;
; PPU_MASK = 0;
;
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ All_On (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_All_On: near

.segment	"CODE"

;
; PPU_CTRL = 0x90; // screen is on, NMI on
;
	lda     #$90
	sta     $2000
;
; PPU_MASK = 0x1e; 
;
	lda     #$1E
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Reset_Scroll (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Reset_Scroll: near

.segment	"CODE"

;
; PPU_ADDRESS = 0;
;
	lda     #$00
	sta     $2006
;
; PPU_ADDRESS = 0;
;
	sta     $2006
;
; SCROLL = 0;
;
	sta     $2005
;
; SCROLL = 0;
;
	sta     $2005
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ Load_Palette (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_Load_Palette: near

.segment	"CODE"

;
; PPU_ADDRESS = 0x3f;
;
	lda     #$3F
	sta     $2006
;
; PPU_ADDRESS = 0x00;
;
	lda     #$00
	sta     $2006
;
; for( index = 0; index < sizeof(PALETTE); ++index ){
;
	sta     _index
L0197:	lda     _index
	cmp     #$20
	bcs     L0085
;
; PPU_DATA = PALETTE[index];
;
	ldy     _index
	lda     _PALETTE,y
	sta     $2007
;
; for( index = 0; index < sizeof(PALETTE); ++index ){
;
	inc     _index
	jmp     L0197
;
; }
;
L0085:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ update_Sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update_Sprites: near

.segment	"CODE"

;
; state4 = state << 2; // same as state * 4
;
	lda     _state
	asl     a
	asl     a
	sta     _state4
;
; index4 = 0;
;
	lda     #$00
	sta     _index4
;
; for (index = 0; index < 4; ++index ){
;
	sta     _index
L019E:	lda     _index
	cmp     #$04
	jcs     L019F
;
; SPRITES[index4] = MetaSprite_Y[index] + A_Y; // relative y + master y
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L00B5
	inx
L00B5:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Y,y
	clc
	adc     _A_Y
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Tile[index + state4]; // tile numbers
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L00BC
	inx
L00BC:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     _index
	clc
	adc     _state4
	bcc     L0199
	inx
L0199:	sta     ptr1
	txa
	clc
	adc     #>(_MetaSprite_Tile)
	sta     ptr1+1
	ldy     #<(_MetaSprite_Tile)
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Attrib[index]; // attributes, all zero here
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L00C2
	inx
L00C2:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Attrib,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_X[index] + A_X; // relative x + master x
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L00C9
	inx
L00C9:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_X,y
	clc
	adc     _A_X
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; for (index = 0; index < 4; ++index ){
;
	inc     _index
	jmp     L019E
;
; B_state4 = B_state << 2; //shift left 2 = multiply 4
;
L019F:	lda     _B_state
	asl     a
	asl     a
	sta     _B_state4
;
; for (index = 0; index < 4; ++index ){   // enemy sprites
;
	lda     #$00
	sta     _index
L01A0:	lda     _index
	cmp     #$04
	bcc     L01A1
;
; }
;
	rts
;
; SPRITES[index4] = MetaSprite_Y[index] + B_Y; // relative y + master y
;
L01A1:	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L00DA
	inx
L00DA:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Y,y
	clc
	adc     _B_Y
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Tile[index + B_state4]; // tile numbers
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L00E1
	inx
L00E1:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     _index
	clc
	adc     _B_state4
	bcc     L019C
	inx
L019C:	sta     ptr1
	txa
	clc
	adc     #>(_MetaSprite_Tile)
	sta     ptr1+1
	ldy     #<(_MetaSprite_Tile)
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Attrib[index] + 1; // attributes, 1 = 2nd palette
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L00E7
	inx
L00E7:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Attrib,y
	clc
	adc     #$01
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_X[index] + B_X; // relative x + master x
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L00EF
	inx
L00EF:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_X,y
	clc
	adc     _B_X
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; for (index = 0; index < 4; ++index ){   // enemy sprites
;
	inc     _index
	jmp     L01A0

.endproc

; ---------------------------------------------------------------
; void __near__ move_logic (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_move_logic: near

.segment	"CODE"

;
; if ((joypad1 & RIGHT) != 0){
;
	lda     _joypad1
	and     #$01
	beq     L01A2
;
; state = Going_Right;
;
	lda     #$00
	sta     _state
;
; ++A_X;
;
	inc     _A_X
;
; if ((joypad1 & LEFT) != 0){
;
L01A2:	lda     _joypad1
	and     #$02
	beq     L01A3
;
; state = Going_Left;
;
	lda     #$02
	sta     _state
;
; --A_X;
;
	dec     _A_X
;
; if ((joypad1 & DOWN) != 0){
;
L01A3:	lda     _joypad1
	and     #$04
	beq     L01A4
;
; state = Going_Down;
;
	lda     #$01
	sta     _state
;
; ++A_Y;
;
	inc     _A_Y
;
; if ((joypad1 & UP) != 0){
;
L01A4:	lda     _joypad1
	and     #$08
	beq     L01A5
;
; state = Going_Up;
;
	lda     #$03
	sta     _state
;
; --A_Y;
;
	dec     _A_Y
;
; if (B_state == Going_Right)
;
L01A5:	lda     _B_state
	bne     L01A6
;
; ++B_X;
;
	inc     _B_X
;
; if (B_state == Going_Down)
;
L01A6:	lda     _B_state
	cmp     #$01
	bne     L01A7
;
; ++B_Y;
;
	inc     _B_Y
;
; if (B_state == Going_Left)
;
L01A7:	lda     _B_state
	cmp     #$02
	bne     L01A8
;
; --B_X;
;
	dec     _B_X
;
; if (B_state == Going_Up)
;
L01A8:	lda     _B_state
	cmp     #$03
	bne     L01A9
;
; --B_Y;
;
	dec     _B_Y
;
; ++B_state_count;
;
L01A9:	inc     _B_state_count
;
; if (B_state_count == 20){ // do a move for 20 frames, then switch
;
	lda     _B_state_count
	cmp     #$14
	bne     L01AA
;
; B_state_count = 0;
;
	lda     #$00
	sta     _B_state_count
;
; ++B_state;
;
	inc     _B_state
;
; if (B_state == 4) // keep it 0-3
;
L01AA:	lda     _B_state
	cmp     #$04
	bne     L0123
;
; B_state = 0;
;
	lda     #$00
	sta     _B_state
;
; }
;
L0123:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ collision (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_collision: near

.segment	"CODE"

;
; A_left_side_X = A_X + 3;
;
	lda     _A_X
	clc
	adc     #$03
	sta     _A_left_side_X
;
; if (A_left_side_X < A_X)  
;
	cmp     _A_X
	bcs     L01AD
;
; A_left_side_X = 255; // if overflow, set to max high
;
	lda     #$FF
	sta     _A_left_side_X
;
; A_right_side_X = A_X + 12;
;
L01AD:	lda     _A_X
	clc
	adc     #$0C
	sta     _A_right_side_X
;
; if (A_right_side_X < A_X)  
;
	cmp     _A_X
	bcs     L01AE
;
; A_right_side_X = 255;
;
	lda     #$FF
	sta     _A_right_side_X
;
; A_top_Y = A_Y;
;
L01AE:	lda     _A_Y
	sta     _A_top_Y
;
; A_bottom_Y = A_Y + 15;
;
	lda     _A_Y
	clc
	adc     #$0F
	sta     _A_bottom_Y
;
; if (A_bottom_Y < A_Y)   
;
	cmp     _A_Y
	bcs     L01AF
;
; A_bottom_Y = 255;
;
	lda     #$FF
	sta     _A_bottom_Y
;
; B_left_side_X = B_X + 3;
;
L01AF:	lda     _B_X
	clc
	adc     #$03
	sta     _B_left_side_X
;
; if (B_left_side_X < B_X)  
;
	cmp     _B_X
	bcs     L01B0
;
; B_left_side_X = 255;
;
	lda     #$FF
	sta     _B_left_side_X
;
; B_right_side_X = B_X + 12;
;
L01B0:	lda     _B_X
	clc
	adc     #$0C
	sta     _B_right_side_X
;
; if (B_right_side_X < B_X)  
;
	cmp     _B_X
	bcs     L01B1
;
; B_right_side_X = 255;
;
	lda     #$FF
	sta     _B_right_side_X
;
; B_top_Y = B_Y;
;
L01B1:	lda     _B_Y
	sta     _B_top_Y
;
; B_bottom_Y = B_Y + 15;
;
	lda     _B_Y
	clc
	adc     #$0F
	sta     _B_bottom_Y
;
; if (B_bottom_Y < B_Y)  
;
	cmp     _B_Y
	bcs     L01B2
;
; B_bottom_Y = 255;
;
	lda     #$FF
	sta     _B_bottom_Y
;
; if (A_left_side_X <= B_right_side_X && A_right_side_X >= B_left_side_X && A_top_Y <= B_bottom_Y && A_bottom_Y >= B_top_Y){
;
L01B2:	lda     _A_left_side_X
	sec
	sbc     _B_right_side_X
	sta     tmp1
	lda     tmp1
	beq     L01B3
	bcs     L01B8
L01B3:	lda     _A_right_side_X
	cmp     _B_left_side_X
	bcc     L01B8
	lda     _A_top_Y
	sec
	sbc     _B_bottom_Y
	sta     tmp1
	lda     tmp1
	beq     L01B4
	bcs     L01B8
L01B4:	lda     _A_bottom_Y
	cmp     _B_top_Y
	bcc     L01B8
;
; ++score5;
;
	inc     _score5
;
; ++PPU_flag; 
;
	inc     _PPU_flag
;
; if (score5 > 9){
;
L01B8:	lda     _score5
	cmp     #$0A
	bcc     L01B9
;
; ++score4;
;
	inc     _score4
;
; score5 = 0;
;
	lda     #$00
	sta     _score5
;
; if (score4 > 9){
;
L01B9:	lda     _score4
	cmp     #$0A
	bcc     L01BA
;
; ++score3;
;
	inc     _score3
;
; score4 = 0;
;
	lda     #$00
	sta     _score4
;
; if (score3 > 9){
;
L01BA:	lda     _score3
	cmp     #$0A
	bcc     L01BB
;
; ++score2;
;
	inc     _score2
;
; score3 = 0;
;
	lda     #$00
	sta     _score3
;
; if (score2 > 9){
;
L01BB:	lda     _score2
	cmp     #$0A
	bcc     L01BC
;
; ++score1;
;
	inc     _score1
;
; score2 = 0;
;
	lda     #$00
	sta     _score2
;
; if (score1 > 9){
;
L01BC:	lda     _score1
	cmp     #$0A
	bcc     L0170
;
; score1 = 0;
;
	lda     #$00
	sta     _score1
;
; score2 = 0;
;
	sta     _score2
;
; score3 = 0;
;
	sta     _score3
;
; score4 = 0;
;
	sta     _score4
;
; score5 = 0;
;
	sta     _score5
;
; }
;
L0170:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ PPU_Update (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_PPU_Update: near

.segment	"CODE"

;
; PPU_ADDRESS = 0x20;
;
	lda     #$20
	sta     $2006
;
; PPU_ADDRESS = 0x8c;
;
	lda     #$8C
	sta     $2006
;
; PPU_DATA = score1+1;//tile 0 = blank, tile 1 = "0", tile 2 = "1", etc
;
	lda     _score1
	clc
	adc     #$01
	sta     $2007
;
; PPU_DATA = score2+1;//so we have to add 1 to the digit to get the corresponding tile
;
	lda     _score2
	clc
	adc     #$01
	sta     $2007
;
; PPU_DATA = score3+1;
;
	lda     _score3
	clc
	adc     #$01
	sta     $2007
;
; PPU_DATA = score4+1;
;
	lda     _score4
	clc
	adc     #$01
	sta     $2007
;
; PPU_DATA = score5+1;
;
	lda     _score5
	clc
	adc     #$01
	sta     $2007
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; All_Off();   // turn off screen
;
	jsr     _All_Off
;
; A_X = 0x20;  // starting x and y
;
	lda     #$20
	sta     _A_X
;
; A_Y = 0x80;
;
	lda     #$80
	sta     _A_Y
;
; B_X = 0x8f;
;
	lda     #$8F
	sta     _B_X
;
; B_Y = 0x77; 
;
	lda     #$77
	sta     _B_Y
;
; PPU_Update (); // start it off with all zeros
;
	jsr     _PPU_Update
;
; Load_Palette();
;
	jsr     _Load_Palette
;
; Reset_Scroll();
;
	jsr     _Reset_Scroll
;
; All_On();   // turn on screen
;
	jsr     _All_On
;
; while (NMI_flag == 0); // wait till NMI
;
L01BD:	lda     _NMI_flag
	beq     L01BD
;
; if (PPU_flag > 0) {
;
	lda     _PPU_flag
	beq     L0056
;
; PPU_Update(); // draw the scoreboard
;
	jsr     _PPU_Update
;
; PPU_flag = 0;
;
	lda     #$00
	sta     _PPU_flag
;
; Reset_Scroll();
;
	jsr     _Reset_Scroll
;
; Get_Input();
;
L0056:	jsr     _Get_Input
;
; move_logic();
;
	jsr     _move_logic
;
; update_Sprites();
;
	jsr     _update_Sprites
;
; collision();
;
	jsr     _collision
;
; NMI_flag = 0;
;
	lda     #$00
	sta     _NMI_flag
;
; while (1){   // infinite loop
;
	jmp     L01BD

.endproc

; ---------------------------------------------------------------
; void __near__ every_frame (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_every_frame: near

.segment	"CODE"

;
; OAM_ADDRESS = 0;
;
	lda     #$00
	sta     $2003
;
; OAM_DMA = 2;  // push all the sprite data from the ram at 200-2ff to the sprite memory
;
	lda     #$02
	sta     $4014
;
; PPU_CTRL = 0x90;  // screen is on, NMI on
;
	lda     #$90
	sta     $2000
;
; PPU_MASK = 0x1e;
;
	lda     #$1E
	sta     $2001
;
; SCROLL = 0;
;
	lda     #$00
	sta     $2005
;
; SCROLL = 0;   // just double checking that the scroll is set to 0
;
	sta     $2005
;
; Get_Input();
;
	jmp     _Get_Input

.endproc

